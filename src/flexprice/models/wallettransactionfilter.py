"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .filtercondition import FilterCondition, FilterConditionTypedDict
from .sortcondition import SortCondition, SortConditionTypedDict
from .status import Status
from .transactionreason import TransactionReason
from .transactionstatus import TransactionStatus
from .transactiontype import TransactionType
from flexprice.types import BaseModel, UNSET_SENTINEL
from pydantic import model_serializer
from typing import List, Literal, Optional
from typing_extensions import NotRequired, TypedDict


WalletTransactionFilterOrder = Literal[
    "asc",
    "desc",
]


class WalletTransactionFilterTypedDict(TypedDict):
    created_by: NotRequired[str]
    credits_available_gt: NotRequired[float]
    end_time: NotRequired[str]
    expand: NotRequired[str]
    expiry_date_after: NotRequired[str]
    expiry_date_before: NotRequired[str]
    filters: NotRequired[List[FilterConditionTypedDict]]
    r"""filters allows complex filtering based on multiple fields"""
    id: NotRequired[str]
    limit: NotRequired[int]
    offset: NotRequired[int]
    order: NotRequired[WalletTransactionFilterOrder]
    priority: NotRequired[int]
    reference_id: NotRequired[str]
    reference_type: NotRequired[str]
    sort: NotRequired[List[SortConditionTypedDict]]
    start_time: NotRequired[str]
    status: NotRequired[Status]
    transaction_reason: NotRequired[TransactionReason]
    transaction_status: NotRequired[TransactionStatus]
    type: NotRequired[TransactionType]


class WalletTransactionFilter(BaseModel):
    created_by: Optional[str] = None

    credits_available_gt: Optional[float] = None

    end_time: Optional[str] = None

    expand: Optional[str] = None

    expiry_date_after: Optional[str] = None

    expiry_date_before: Optional[str] = None

    filters: Optional[List[FilterCondition]] = None
    r"""filters allows complex filtering based on multiple fields"""

    id: Optional[str] = None

    limit: Optional[int] = None

    offset: Optional[int] = None

    order: Optional[WalletTransactionFilterOrder] = None

    priority: Optional[int] = None

    reference_id: Optional[str] = None

    reference_type: Optional[str] = None

    sort: Optional[List[SortCondition]] = None

    start_time: Optional[str] = None

    status: Optional[Status] = None

    transaction_reason: Optional[TransactionReason] = None

    transaction_status: Optional[TransactionStatus] = None

    type: Optional[TransactionType] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "created_by",
                "credits_available_gt",
                "end_time",
                "expand",
                "expiry_date_after",
                "expiry_date_before",
                "filters",
                "id",
                "limit",
                "offset",
                "order",
                "priority",
                "reference_id",
                "reference_type",
                "sort",
                "start_time",
                "status",
                "transaction_reason",
                "transaction_status",
                "type",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m
