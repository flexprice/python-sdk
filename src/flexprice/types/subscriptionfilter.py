"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .billingcadence import BillingCadence
from .billingperiod import BillingPeriod
from .filtercondition import FilterCondition, FilterConditionTypedDict
from .sortcondition import SortCondition, SortConditionTypedDict
from .status import Status
from .subscriptionstatus import SubscriptionStatus
from flexprice.types import BaseModel, UNSET_SENTINEL
from pydantic import model_serializer
from typing import List, Literal, Optional
from typing_extensions import NotRequired, TypedDict


SubscriptionFilterOrder = Literal[
    "asc",
    "desc",
]


class SubscriptionFilterTypedDict(TypedDict):
    active_at: NotRequired[str]
    r"""ActiveAt filters subscriptions that are active at the given time"""
    billing_cadence: NotRequired[List[BillingCadence]]
    r"""BillingCadence filters by billing cadence"""
    billing_period: NotRequired[List[BillingPeriod]]
    r"""BillingPeriod filters by billing period"""
    customer_id: NotRequired[str]
    r"""CustomerID filters by customer ID"""
    end_time: NotRequired[str]
    expand: NotRequired[str]
    external_customer_id: NotRequired[str]
    r"""ExternalCustomerID filters by external customer ID"""
    filters: NotRequired[List[FilterConditionTypedDict]]
    invoicing_customer_ids: NotRequired[List[str]]
    r"""InvoicingCustomerIDs filters by invoicing customer ID"""
    limit: NotRequired[int]
    offset: NotRequired[int]
    order: NotRequired[SubscriptionFilterOrder]
    parent_subscription_ids: NotRequired[List[str]]
    r"""ParentSubscriptionIDs filters by parent subscription IDs"""
    plan_id: NotRequired[str]
    r"""PlanID filters by plan ID"""
    sort: NotRequired[List[SortConditionTypedDict]]
    start_time: NotRequired[str]
    status: NotRequired[Status]
    subscription_ids: NotRequired[List[str]]
    subscription_status: NotRequired[List[SubscriptionStatus]]
    r"""SubscriptionStatus filters by subscription status"""
    with_line_items: NotRequired[bool]
    r"""WithLineItems includes line items in the response"""


class SubscriptionFilter(BaseModel):
    active_at: Optional[str] = None
    r"""ActiveAt filters subscriptions that are active at the given time"""

    billing_cadence: Optional[List[BillingCadence]] = None
    r"""BillingCadence filters by billing cadence"""

    billing_period: Optional[List[BillingPeriod]] = None
    r"""BillingPeriod filters by billing period"""

    customer_id: Optional[str] = None
    r"""CustomerID filters by customer ID"""

    end_time: Optional[str] = None

    expand: Optional[str] = None

    external_customer_id: Optional[str] = None
    r"""ExternalCustomerID filters by external customer ID"""

    filters: Optional[List[FilterCondition]] = None

    invoicing_customer_ids: Optional[List[str]] = None
    r"""InvoicingCustomerIDs filters by invoicing customer ID"""

    limit: Optional[int] = None

    offset: Optional[int] = None

    order: Optional[SubscriptionFilterOrder] = None

    parent_subscription_ids: Optional[List[str]] = None
    r"""ParentSubscriptionIDs filters by parent subscription IDs"""

    plan_id: Optional[str] = None
    r"""PlanID filters by plan ID"""

    sort: Optional[List[SortCondition]] = None

    start_time: Optional[str] = None

    status: Optional[Status] = None

    subscription_ids: Optional[List[str]] = None

    subscription_status: Optional[List[SubscriptionStatus]] = None
    r"""SubscriptionStatus filters by subscription status"""

    with_line_items: Optional[bool] = None
    r"""WithLineItems includes line items in the response"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "active_at",
                "billing_cadence",
                "billing_period",
                "customer_id",
                "end_time",
                "expand",
                "external_customer_id",
                "filters",
                "invoicing_customer_ids",
                "limit",
                "offset",
                "order",
                "parent_subscription_ids",
                "plan_id",
                "sort",
                "start_time",
                "status",
                "subscription_ids",
                "subscription_status",
                "with_line_items",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m
