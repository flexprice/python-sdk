"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .alertentitytype import AlertEntityType
from .alertstate import AlertState
from .alerttype import AlertType
from .filtercondition import FilterCondition, FilterConditionTypedDict
from .sortcondition import SortCondition, SortConditionTypedDict
from .status import Status
from flexprice.types import BaseModel, UNSET_SENTINEL
from pydantic import model_serializer
from typing import List, Literal, Optional
from typing_extensions import NotRequired, TypedDict


AlertLogFilterOrder = Literal[
    "asc",
    "desc",
]


class AlertLogFilterTypedDict(TypedDict):
    alert_status: NotRequired[AlertState]
    alert_type: NotRequired[AlertType]
    customer_id: NotRequired[str]
    end_time: NotRequired[str]
    entity_id: NotRequired[str]
    entity_type: NotRequired[AlertEntityType]
    expand: NotRequired[str]
    filters: NotRequired[List[FilterConditionTypedDict]]
    r"""filters allows complex filtering based on multiple fields"""
    limit: NotRequired[int]
    offset: NotRequired[int]
    order: NotRequired[AlertLogFilterOrder]
    sort: NotRequired[List[SortConditionTypedDict]]
    start_time: NotRequired[str]
    status: NotRequired[Status]


class AlertLogFilter(BaseModel):
    alert_status: Optional[AlertState] = None

    alert_type: Optional[AlertType] = None

    customer_id: Optional[str] = None

    end_time: Optional[str] = None

    entity_id: Optional[str] = None

    entity_type: Optional[AlertEntityType] = None

    expand: Optional[str] = None

    filters: Optional[List[FilterCondition]] = None
    r"""filters allows complex filtering based on multiple fields"""

    limit: Optional[int] = None

    offset: Optional[int] = None

    order: Optional[AlertLogFilterOrder] = None

    sort: Optional[List[SortCondition]] = None

    start_time: Optional[str] = None

    status: Optional[Status] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "alert_status",
                "alert_type",
                "customer_id",
                "end_time",
                "entity_id",
                "entity_type",
                "expand",
                "filters",
                "limit",
                "offset",
                "order",
                "sort",
                "start_time",
                "status",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m
