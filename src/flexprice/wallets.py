"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from flexprice import models, utils
from flexprice._hooks import HookContext
from flexprice.types import OptionalNullable, UNSET
from flexprice.utils.unmarshal_json_response import unmarshal_json_response
from typing import Any, Dict, List, Mapping, Optional, Union


class Wallets(BaseSDK):
    def get_customer_wallets(
        self,
        *,
        minus: Optional[int] = None,
        expand: Optional[str] = None,
        from_cache: Optional[bool] = False,
        id: Optional[str] = None,
        include_real_time_balance: Optional[bool] = False,
        lookup_key: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.DtoWalletResponse]:
        r"""Get Customer Wallets

        Use when resolving wallets by external customer id or lookup key (e.g. from your app's user id). Supports optional real-time balance and expand.

        :param minus: populated from x-max-live header, not query param
        :param expand:
        :param from_cache:
        :param id:
        :param include_real_time_balance:
        :param lookup_key:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetCustomerWalletsRequest(
            minus=minus,
            expand=expand,
            from_cache=from_cache,
            id=id,
            include_real_time_balance=include_real_time_balance,
            lookup_key=lookup_key,
        )

        req = self._build_request(
            method="GET",
            path="/customers/wallets",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getCustomerWallets",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[models.DtoWalletResponse], http_res)
        if utils.match_response(http_res, ["400", "404"], "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise models.errors.FlexpriceDefaultError(
            "Unexpected response received", http_res
        )

    async def get_customer_wallets_async(
        self,
        *,
        minus: Optional[int] = None,
        expand: Optional[str] = None,
        from_cache: Optional[bool] = False,
        id: Optional[str] = None,
        include_real_time_balance: Optional[bool] = False,
        lookup_key: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.DtoWalletResponse]:
        r"""Get Customer Wallets

        Use when resolving wallets by external customer id or lookup key (e.g. from your app's user id). Supports optional real-time balance and expand.

        :param minus: populated from x-max-live header, not query param
        :param expand:
        :param from_cache:
        :param id:
        :param include_real_time_balance:
        :param lookup_key:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetCustomerWalletsRequest(
            minus=minus,
            expand=expand,
            from_cache=from_cache,
            id=id,
            include_real_time_balance=include_real_time_balance,
            lookup_key=lookup_key,
        )

        req = self._build_request_async(
            method="GET",
            path="/customers/wallets",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getCustomerWallets",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[models.DtoWalletResponse], http_res)
        if utils.match_response(http_res, ["400", "404"], "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise models.errors.FlexpriceDefaultError(
            "Unexpected response received", http_res
        )

    def get_wallets_by_customer_id(
        self,
        *,
        id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.DtoWalletResponse]:
        r"""Get wallets by customer ID

        Use when showing a customer's wallets (e.g. balance overview by currency or in a billing portal). Supports optional expand for balance breakdown.

        :param id: Customer ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetWalletsByCustomerIDRequest(
            id=id,
        )

        req = self._build_request(
            method="GET",
            path="/customers/{id}/wallets",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getWalletsByCustomerId",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[models.DtoWalletResponse], http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise models.errors.FlexpriceDefaultError(
            "Unexpected response received", http_res
        )

    async def get_wallets_by_customer_id_async(
        self,
        *,
        id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.DtoWalletResponse]:
        r"""Get wallets by customer ID

        Use when showing a customer's wallets (e.g. balance overview by currency or in a billing portal). Supports optional expand for balance breakdown.

        :param id: Customer ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetWalletsByCustomerIDRequest(
            id=id,
        )

        req = self._build_request_async(
            method="GET",
            path="/customers/{id}/wallets",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getWalletsByCustomerId",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[models.DtoWalletResponse], http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise models.errors.FlexpriceDefaultError(
            "Unexpected response received", http_res
        )

    def create_wallet(
        self,
        *,
        currency: str,
        alert_settings: Optional[
            Union[models.AlertSettings, models.AlertSettingsTypedDict]
        ] = None,
        auto_topup: Optional[Union[models.AutoTopup, models.AutoTopupTypedDict]] = None,
        conversion_rate: Optional[str] = "1",
        customer_id: Optional[str] = None,
        description: Optional[str] = None,
        external_customer_id: Optional[str] = None,
        initial_credits_expiry_date_utc: Optional[str] = None,
        initial_credits_to_load: Optional[str] = "0",
        initial_credits_to_load_expiry_date: Optional[int] = None,
        metadata: Optional[Dict[str, str]] = None,
        price_unit: Optional[str] = None,
        topup_conversion_rate: Optional[str] = None,
        wallet_type: Optional[models.WalletType] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DtoWalletResponse:
        r"""Create a new wallet

        Use when giving a customer a prepaid or credit balance (e.g. prepaid plans or promotional credits).

        :param currency:
        :param alert_settings:
        :param auto_topup:
        :param conversion_rate: amount in the currency =  number of credits * conversion_rate
            ex if conversion_rate is 1, then 1 USD = 1 credit
            ex if conversion_rate is 2, then 1 USD = 0.5 credits
            ex if conversion_rate is 0.5, then 1 USD = 2 credits
        :param customer_id:
        :param description:
        :param external_customer_id: external_customer_id is the customer id in the external system
        :param initial_credits_expiry_date_utc: initial_credits_expiry_date_utc is the expiry date in UTC timezone (optional to set nil means no expiry)
            ex 2025-01-01 00:00:00 UTC
        :param initial_credits_to_load: initial_credits_to_load is the number of credits to load to the wallet
            if not provided, the wallet will be created with 0 balance
            NOTE: this is not the amount in the currency, but the number of credits
        :param initial_credits_to_load_expiry_date: initial_credits_to_load_expiry_date YYYYMMDD format in UTC timezone (optional to set nil means no expiry)
            for ex 20250101 means the credits will expire on 2025-01-01 00:00:00 UTC
            hence they will be available for use until 2024-12-31 23:59:59 UTC
        :param metadata:
        :param price_unit: price_unit is the code of the price unit to use for wallet creation
            If provided, the price unit will be used to set the currency and conversion rate of the wallet:
            - currency: set to price unit's base_currency
            - conversion_rate: set to price unit's conversion_rate
        :param topup_conversion_rate: topup_conversion_rate is the conversion rate for the topup to the currency
            ex if topup_conversion_rate is 1, then 1 USD = 1 credit
            ex if topup_conversion_rate is 2, then 1 USD = 0.5 credits
            ex if topup_conversion_rate is 0.5, then 1 USD = 2 credits
        :param wallet_type:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DtoCreateWalletRequest(
            alert_settings=utils.get_pydantic_model(
                alert_settings, Optional[models.AlertSettings]
            ),
            auto_topup=utils.get_pydantic_model(auto_topup, Optional[models.AutoTopup]),
            conversion_rate=conversion_rate,
            currency=currency,
            customer_id=customer_id,
            description=description,
            external_customer_id=external_customer_id,
            initial_credits_expiry_date_utc=initial_credits_expiry_date_utc,
            initial_credits_to_load=initial_credits_to_load,
            initial_credits_to_load_expiry_date=initial_credits_to_load_expiry_date,
            metadata=metadata,
            price_unit=price_unit,
            topup_conversion_rate=topup_conversion_rate,
            wallet_type=wallet_type,
        )

        req = self._build_request(
            method="POST",
            path="/wallets",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.DtoCreateWalletRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="createWallet",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DtoWalletResponse, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise models.errors.FlexpriceDefaultError(
            "Unexpected response received", http_res
        )

    async def create_wallet_async(
        self,
        *,
        currency: str,
        alert_settings: Optional[
            Union[models.AlertSettings, models.AlertSettingsTypedDict]
        ] = None,
        auto_topup: Optional[Union[models.AutoTopup, models.AutoTopupTypedDict]] = None,
        conversion_rate: Optional[str] = "1",
        customer_id: Optional[str] = None,
        description: Optional[str] = None,
        external_customer_id: Optional[str] = None,
        initial_credits_expiry_date_utc: Optional[str] = None,
        initial_credits_to_load: Optional[str] = "0",
        initial_credits_to_load_expiry_date: Optional[int] = None,
        metadata: Optional[Dict[str, str]] = None,
        price_unit: Optional[str] = None,
        topup_conversion_rate: Optional[str] = None,
        wallet_type: Optional[models.WalletType] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DtoWalletResponse:
        r"""Create a new wallet

        Use when giving a customer a prepaid or credit balance (e.g. prepaid plans or promotional credits).

        :param currency:
        :param alert_settings:
        :param auto_topup:
        :param conversion_rate: amount in the currency =  number of credits * conversion_rate
            ex if conversion_rate is 1, then 1 USD = 1 credit
            ex if conversion_rate is 2, then 1 USD = 0.5 credits
            ex if conversion_rate is 0.5, then 1 USD = 2 credits
        :param customer_id:
        :param description:
        :param external_customer_id: external_customer_id is the customer id in the external system
        :param initial_credits_expiry_date_utc: initial_credits_expiry_date_utc is the expiry date in UTC timezone (optional to set nil means no expiry)
            ex 2025-01-01 00:00:00 UTC
        :param initial_credits_to_load: initial_credits_to_load is the number of credits to load to the wallet
            if not provided, the wallet will be created with 0 balance
            NOTE: this is not the amount in the currency, but the number of credits
        :param initial_credits_to_load_expiry_date: initial_credits_to_load_expiry_date YYYYMMDD format in UTC timezone (optional to set nil means no expiry)
            for ex 20250101 means the credits will expire on 2025-01-01 00:00:00 UTC
            hence they will be available for use until 2024-12-31 23:59:59 UTC
        :param metadata:
        :param price_unit: price_unit is the code of the price unit to use for wallet creation
            If provided, the price unit will be used to set the currency and conversion rate of the wallet:
            - currency: set to price unit's base_currency
            - conversion_rate: set to price unit's conversion_rate
        :param topup_conversion_rate: topup_conversion_rate is the conversion rate for the topup to the currency
            ex if topup_conversion_rate is 1, then 1 USD = 1 credit
            ex if topup_conversion_rate is 2, then 1 USD = 0.5 credits
            ex if topup_conversion_rate is 0.5, then 1 USD = 2 credits
        :param wallet_type:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DtoCreateWalletRequest(
            alert_settings=utils.get_pydantic_model(
                alert_settings, Optional[models.AlertSettings]
            ),
            auto_topup=utils.get_pydantic_model(auto_topup, Optional[models.AutoTopup]),
            conversion_rate=conversion_rate,
            currency=currency,
            customer_id=customer_id,
            description=description,
            external_customer_id=external_customer_id,
            initial_credits_expiry_date_utc=initial_credits_expiry_date_utc,
            initial_credits_to_load=initial_credits_to_load,
            initial_credits_to_load_expiry_date=initial_credits_to_load_expiry_date,
            metadata=metadata,
            price_unit=price_unit,
            topup_conversion_rate=topup_conversion_rate,
            wallet_type=wallet_type,
        )

        req = self._build_request_async(
            method="POST",
            path="/wallets",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.DtoCreateWalletRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="createWallet",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DtoWalletResponse, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise models.errors.FlexpriceDefaultError(
            "Unexpected response received", http_res
        )

    def query_wallet(
        self,
        *,
        alert_enabled: Optional[bool] = None,
        expand: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        order: Optional[models.WalletFilterOrder] = None,
        sort: Optional[str] = None,
        status: Optional[models.WalletStatus] = None,
        wallet_ids: Optional[List[str]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ListResponseDtoWalletResponse:
        r"""Query wallets

        Use when listing or searching wallets (e.g. admin view or reporting). Returns a paginated list; supports filtering by customer and status.

        :param alert_enabled:
        :param expand:
        :param limit:
        :param offset:
        :param order:
        :param sort:
        :param status:
        :param wallet_ids:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.WalletFilter(
            alert_enabled=alert_enabled,
            expand=expand,
            limit=limit,
            offset=offset,
            order=order,
            sort=sort,
            status=status,
            wallet_ids=wallet_ids,
        )

        req = self._build_request(
            method="POST",
            path="/wallets/search",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.WalletFilter
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="queryWallet",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.ListResponseDtoWalletResponse, http_res
            )
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise models.errors.FlexpriceDefaultError(
            "Unexpected response received", http_res
        )

    async def query_wallet_async(
        self,
        *,
        alert_enabled: Optional[bool] = None,
        expand: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        order: Optional[models.WalletFilterOrder] = None,
        sort: Optional[str] = None,
        status: Optional[models.WalletStatus] = None,
        wallet_ids: Optional[List[str]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ListResponseDtoWalletResponse:
        r"""Query wallets

        Use when listing or searching wallets (e.g. admin view or reporting). Returns a paginated list; supports filtering by customer and status.

        :param alert_enabled:
        :param expand:
        :param limit:
        :param offset:
        :param order:
        :param sort:
        :param status:
        :param wallet_ids:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.WalletFilter(
            alert_enabled=alert_enabled,
            expand=expand,
            limit=limit,
            offset=offset,
            order=order,
            sort=sort,
            status=status,
            wallet_ids=wallet_ids,
        )

        req = self._build_request_async(
            method="POST",
            path="/wallets/search",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.WalletFilter
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="queryWallet",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.ListResponseDtoWalletResponse, http_res
            )
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise models.errors.FlexpriceDefaultError(
            "Unexpected response received", http_res
        )

    def query_wallet_transaction(
        self,
        *,
        created_by: Optional[str] = None,
        credits_available_gt: Optional[float] = None,
        end_time: Optional[str] = None,
        expand: Optional[str] = None,
        expiry_date_after: Optional[str] = None,
        expiry_date_before: Optional[str] = None,
        filters: Optional[
            Union[List[models.FilterCondition], List[models.FilterConditionTypedDict]]
        ] = None,
        id: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        order: Optional[models.WalletTransactionFilterOrder] = None,
        priority: Optional[int] = None,
        reference_id: Optional[str] = None,
        reference_type: Optional[str] = None,
        sort: Optional[
            Union[List[models.SortCondition], List[models.SortConditionTypedDict]]
        ] = None,
        start_time: Optional[str] = None,
        status: Optional[models.Status] = None,
        transaction_reason: Optional[models.TransactionReason] = None,
        transaction_status: Optional[models.TransactionStatus] = None,
        type_: Optional[models.TransactionType] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DtoListWalletTransactionsResponse:
        r"""Query wallet transactions

        Use when searching or reporting on wallet transactions (e.g. cross-wallet history or reconciliation). Returns a paginated list; supports filtering by wallet, customer, type, date range.

        :param created_by:
        :param credits_available_gt:
        :param end_time:
        :param expand:
        :param expiry_date_after:
        :param expiry_date_before:
        :param filters: filters allows complex filtering based on multiple fields
        :param id:
        :param limit:
        :param offset:
        :param order:
        :param priority:
        :param reference_id:
        :param reference_type:
        :param sort:
        :param start_time:
        :param status:
        :param transaction_reason:
        :param transaction_status:
        :param type:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.WalletTransactionFilter(
            created_by=created_by,
            credits_available_gt=credits_available_gt,
            end_time=end_time,
            expand=expand,
            expiry_date_after=expiry_date_after,
            expiry_date_before=expiry_date_before,
            filters=utils.get_pydantic_model(
                filters, Optional[List[models.FilterCondition]]
            ),
            id=id,
            limit=limit,
            offset=offset,
            order=order,
            priority=priority,
            reference_id=reference_id,
            reference_type=reference_type,
            sort=utils.get_pydantic_model(sort, Optional[List[models.SortCondition]]),
            start_time=start_time,
            status=status,
            transaction_reason=transaction_reason,
            transaction_status=transaction_status,
            type=type_,
        )

        req = self._build_request(
            method="POST",
            path="/wallets/transactions/search",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.WalletTransactionFilter
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="queryWalletTransaction",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.DtoListWalletTransactionsResponse, http_res
            )
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise models.errors.FlexpriceDefaultError(
            "Unexpected response received", http_res
        )

    async def query_wallet_transaction_async(
        self,
        *,
        created_by: Optional[str] = None,
        credits_available_gt: Optional[float] = None,
        end_time: Optional[str] = None,
        expand: Optional[str] = None,
        expiry_date_after: Optional[str] = None,
        expiry_date_before: Optional[str] = None,
        filters: Optional[
            Union[List[models.FilterCondition], List[models.FilterConditionTypedDict]]
        ] = None,
        id: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        order: Optional[models.WalletTransactionFilterOrder] = None,
        priority: Optional[int] = None,
        reference_id: Optional[str] = None,
        reference_type: Optional[str] = None,
        sort: Optional[
            Union[List[models.SortCondition], List[models.SortConditionTypedDict]]
        ] = None,
        start_time: Optional[str] = None,
        status: Optional[models.Status] = None,
        transaction_reason: Optional[models.TransactionReason] = None,
        transaction_status: Optional[models.TransactionStatus] = None,
        type_: Optional[models.TransactionType] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DtoListWalletTransactionsResponse:
        r"""Query wallet transactions

        Use when searching or reporting on wallet transactions (e.g. cross-wallet history or reconciliation). Returns a paginated list; supports filtering by wallet, customer, type, date range.

        :param created_by:
        :param credits_available_gt:
        :param end_time:
        :param expand:
        :param expiry_date_after:
        :param expiry_date_before:
        :param filters: filters allows complex filtering based on multiple fields
        :param id:
        :param limit:
        :param offset:
        :param order:
        :param priority:
        :param reference_id:
        :param reference_type:
        :param sort:
        :param start_time:
        :param status:
        :param transaction_reason:
        :param transaction_status:
        :param type:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.WalletTransactionFilter(
            created_by=created_by,
            credits_available_gt=credits_available_gt,
            end_time=end_time,
            expand=expand,
            expiry_date_after=expiry_date_after,
            expiry_date_before=expiry_date_before,
            filters=utils.get_pydantic_model(
                filters, Optional[List[models.FilterCondition]]
            ),
            id=id,
            limit=limit,
            offset=offset,
            order=order,
            priority=priority,
            reference_id=reference_id,
            reference_type=reference_type,
            sort=utils.get_pydantic_model(sort, Optional[List[models.SortCondition]]),
            start_time=start_time,
            status=status,
            transaction_reason=transaction_reason,
            transaction_status=transaction_status,
            type=type_,
        )

        req = self._build_request_async(
            method="POST",
            path="/wallets/transactions/search",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.WalletTransactionFilter
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="queryWalletTransaction",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.DtoListWalletTransactionsResponse, http_res
            )
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise models.errors.FlexpriceDefaultError(
            "Unexpected response received", http_res
        )

    def get_wallet(
        self,
        *,
        id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DtoWalletResponse:
        r"""Get wallet

        Use when you need to load a single wallet (e.g. for a balance or settings view).

        :param id: Wallet ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetWalletRequest(
            id=id,
        )

        req = self._build_request(
            method="GET",
            path="/wallets/{id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getWallet",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DtoWalletResponse, http_res)
        if utils.match_response(http_res, ["400", "404"], "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise models.errors.FlexpriceDefaultError(
            "Unexpected response received", http_res
        )

    async def get_wallet_async(
        self,
        *,
        id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DtoWalletResponse:
        r"""Get wallet

        Use when you need to load a single wallet (e.g. for a balance or settings view).

        :param id: Wallet ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetWalletRequest(
            id=id,
        )

        req = self._build_request_async(
            method="GET",
            path="/wallets/{id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getWallet",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DtoWalletResponse, http_res)
        if utils.match_response(http_res, ["400", "404"], "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise models.errors.FlexpriceDefaultError(
            "Unexpected response received", http_res
        )

    def update_wallet(
        self,
        *,
        id: str,
        alert_settings: Optional[
            Union[models.AlertSettings, models.AlertSettingsTypedDict]
        ] = None,
        auto_topup: Optional[Union[models.AutoTopup, models.AutoTopupTypedDict]] = None,
        config: Optional[
            Union[models.WalletConfig, models.WalletConfigTypedDict]
        ] = None,
        description: Optional[str] = None,
        metadata: Optional[Dict[str, str]] = None,
        name: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DtoWalletResponse:
        r"""Update a wallet

        Use when changing wallet settings (e.g. enabling or updating auto top-up thresholds).

        :param id: Wallet ID
        :param alert_settings:
        :param auto_topup:
        :param config:
        :param description:
        :param metadata:
        :param name:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateWalletRequest(
            id=id,
            body=models.DtoUpdateWalletRequest(
                alert_settings=utils.get_pydantic_model(
                    alert_settings, Optional[models.AlertSettings]
                ),
                auto_topup=utils.get_pydantic_model(
                    auto_topup, Optional[models.AutoTopup]
                ),
                config=utils.get_pydantic_model(config, Optional[models.WalletConfig]),
                description=description,
                metadata=metadata,
                name=name,
            ),
        )

        req = self._build_request(
            method="PUT",
            path="/wallets/{id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.body, False, False, "json", models.DtoUpdateWalletRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="updateWallet",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DtoWalletResponse, http_res)
        if utils.match_response(http_res, ["400", "404"], "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise models.errors.FlexpriceDefaultError(
            "Unexpected response received", http_res
        )

    async def update_wallet_async(
        self,
        *,
        id: str,
        alert_settings: Optional[
            Union[models.AlertSettings, models.AlertSettingsTypedDict]
        ] = None,
        auto_topup: Optional[Union[models.AutoTopup, models.AutoTopupTypedDict]] = None,
        config: Optional[
            Union[models.WalletConfig, models.WalletConfigTypedDict]
        ] = None,
        description: Optional[str] = None,
        metadata: Optional[Dict[str, str]] = None,
        name: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DtoWalletResponse:
        r"""Update a wallet

        Use when changing wallet settings (e.g. enabling or updating auto top-up thresholds).

        :param id: Wallet ID
        :param alert_settings:
        :param auto_topup:
        :param config:
        :param description:
        :param metadata:
        :param name:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateWalletRequest(
            id=id,
            body=models.DtoUpdateWalletRequest(
                alert_settings=utils.get_pydantic_model(
                    alert_settings, Optional[models.AlertSettings]
                ),
                auto_topup=utils.get_pydantic_model(
                    auto_topup, Optional[models.AutoTopup]
                ),
                config=utils.get_pydantic_model(config, Optional[models.WalletConfig]),
                description=description,
                metadata=metadata,
                name=name,
            ),
        )

        req = self._build_request_async(
            method="PUT",
            path="/wallets/{id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.body, False, False, "json", models.DtoUpdateWalletRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="updateWallet",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DtoWalletResponse, http_res)
        if utils.match_response(http_res, ["400", "404"], "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise models.errors.FlexpriceDefaultError(
            "Unexpected response received", http_res
        )

    def get_wallet_balance(
        self,
        *,
        id: str,
        expand: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DtoWalletBalanceResponse:
        r"""Get wallet balance

        Use when displaying or checking current wallet balance (e.g. before charging or in a portal). Supports optional expand for credits breakdown and from_cache.

        :param id: Wallet ID
        :param expand: Expand fields (e.g., credits_available_breakdown)
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetWalletBalanceRequest(
            id=id,
            expand=expand,
        )

        req = self._build_request(
            method="GET",
            path="/wallets/{id}/balance/real-time",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getWalletBalance",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DtoWalletBalanceResponse, http_res)
        if utils.match_response(http_res, ["400", "404"], "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise models.errors.FlexpriceDefaultError(
            "Unexpected response received", http_res
        )

    async def get_wallet_balance_async(
        self,
        *,
        id: str,
        expand: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DtoWalletBalanceResponse:
        r"""Get wallet balance

        Use when displaying or checking current wallet balance (e.g. before charging or in a portal). Supports optional expand for credits breakdown and from_cache.

        :param id: Wallet ID
        :param expand: Expand fields (e.g., credits_available_breakdown)
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetWalletBalanceRequest(
            id=id,
            expand=expand,
        )

        req = self._build_request_async(
            method="GET",
            path="/wallets/{id}/balance/real-time",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getWalletBalance",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DtoWalletBalanceResponse, http_res)
        if utils.match_response(http_res, ["400", "404"], "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise models.errors.FlexpriceDefaultError(
            "Unexpected response received", http_res
        )

    def terminate_wallet(
        self,
        *,
        id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DtoWalletResponse:
        r"""Terminate a wallet

        Use when closing a customer wallet (e.g. churn or migration). Closes the wallet and applies remaining balance per policy (refund or forfeit).

        :param id: Wallet ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.TerminateWalletRequest(
            id=id,
        )

        req = self._build_request(
            method="POST",
            path="/wallets/{id}/terminate",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="terminateWallet",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DtoWalletResponse, http_res)
        if utils.match_response(http_res, ["400", "404"], "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise models.errors.FlexpriceDefaultError(
            "Unexpected response received", http_res
        )

    async def terminate_wallet_async(
        self,
        *,
        id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DtoWalletResponse:
        r"""Terminate a wallet

        Use when closing a customer wallet (e.g. churn or migration). Closes the wallet and applies remaining balance per policy (refund or forfeit).

        :param id: Wallet ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.TerminateWalletRequest(
            id=id,
        )

        req = self._build_request_async(
            method="POST",
            path="/wallets/{id}/terminate",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="terminateWallet",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DtoWalletResponse, http_res)
        if utils.match_response(http_res, ["400", "404"], "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise models.errors.FlexpriceDefaultError(
            "Unexpected response received", http_res
        )

    def top_up_wallet(
        self,
        *,
        id: str,
        transaction_reason: models.TransactionReason,
        amount: Optional[str] = None,
        credits_to_add: Optional[str] = None,
        description: Optional[str] = None,
        expiry_date_utc: Optional[str] = None,
        idempotency_key: Optional[str] = None,
        metadata: Optional[Dict[str, str]] = None,
        priority: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DtoTopUpWalletResponse:
        r"""Top up wallet

        Use when adding funds to a wallet (e.g. top-up, refund, or manual credit). Supports optional idempotency via reference.

        :param id: Wallet ID
        :param transaction_reason:
        :param amount: amount is the amount in the currency of the wallet to be added
            NOTE: this is not the number of credits to add, but the amount in the currency
            amount = credits_to_add * conversion_rate
            if both amount and credits_to_add are provided, amount will be ignored
            ex if the wallet has a conversion_rate of 2 then adding an amount of
            10 USD in the wallet wil add 5 credits in the wallet
        :param credits_to_add: credits_to_add is the number of credits to add to the wallet
        :param description: description to add any specific details about the transaction
        :param expiry_date_utc: expiry_date_utc is the expiry date in UTC timezone
            ex 2025-01-01 00:00:00 UTC
        :param idempotency_key: idempotency_key is a unique key for the transaction
        :param metadata:
        :param priority: priority is the priority of the transaction
            lower number means higher priority
            default is nil which means no priority at all
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.TopUpWalletRequest(
            id=id,
            body=models.DtoTopUpWalletRequest(
                amount=amount,
                credits_to_add=credits_to_add,
                description=description,
                expiry_date_utc=expiry_date_utc,
                idempotency_key=idempotency_key,
                metadata=metadata,
                priority=priority,
                transaction_reason=transaction_reason,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/wallets/{id}/top-up",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.body, False, False, "json", models.DtoTopUpWalletRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="topUpWallet",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DtoTopUpWalletResponse, http_res)
        if utils.match_response(http_res, ["400", "404"], "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise models.errors.FlexpriceDefaultError(
            "Unexpected response received", http_res
        )

    async def top_up_wallet_async(
        self,
        *,
        id: str,
        transaction_reason: models.TransactionReason,
        amount: Optional[str] = None,
        credits_to_add: Optional[str] = None,
        description: Optional[str] = None,
        expiry_date_utc: Optional[str] = None,
        idempotency_key: Optional[str] = None,
        metadata: Optional[Dict[str, str]] = None,
        priority: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DtoTopUpWalletResponse:
        r"""Top up wallet

        Use when adding funds to a wallet (e.g. top-up, refund, or manual credit). Supports optional idempotency via reference.

        :param id: Wallet ID
        :param transaction_reason:
        :param amount: amount is the amount in the currency of the wallet to be added
            NOTE: this is not the number of credits to add, but the amount in the currency
            amount = credits_to_add * conversion_rate
            if both amount and credits_to_add are provided, amount will be ignored
            ex if the wallet has a conversion_rate of 2 then adding an amount of
            10 USD in the wallet wil add 5 credits in the wallet
        :param credits_to_add: credits_to_add is the number of credits to add to the wallet
        :param description: description to add any specific details about the transaction
        :param expiry_date_utc: expiry_date_utc is the expiry date in UTC timezone
            ex 2025-01-01 00:00:00 UTC
        :param idempotency_key: idempotency_key is a unique key for the transaction
        :param metadata:
        :param priority: priority is the priority of the transaction
            lower number means higher priority
            default is nil which means no priority at all
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.TopUpWalletRequest(
            id=id,
            body=models.DtoTopUpWalletRequest(
                amount=amount,
                credits_to_add=credits_to_add,
                description=description,
                expiry_date_utc=expiry_date_utc,
                idempotency_key=idempotency_key,
                metadata=metadata,
                priority=priority,
                transaction_reason=transaction_reason,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/wallets/{id}/top-up",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.body, False, False, "json", models.DtoTopUpWalletRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="topUpWallet",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DtoTopUpWalletResponse, http_res)
        if utils.match_response(http_res, ["400", "404"], "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise models.errors.FlexpriceDefaultError(
            "Unexpected response received", http_res
        )

    def get_wallet_transactions(
        self,
        *,
        id_path_parameter: str,
        created_by: Optional[str] = None,
        credits_available_gt: Optional[float] = None,
        end_time: Optional[str] = None,
        expand: Optional[str] = None,
        expiry_date_after: Optional[str] = None,
        expiry_date_before: Optional[str] = None,
        id_query_parameter: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        order: Optional[models.GetWalletTransactionsOrder] = None,
        priority: Optional[int] = None,
        reference_id: Optional[str] = None,
        reference_type: Optional[str] = None,
        start_time: Optional[str] = None,
        status: Optional[models.GetWalletTransactionsStatus] = None,
        transaction_reason: Optional[
            models.GetWalletTransactionsTransactionReason
        ] = None,
        transaction_status: Optional[
            models.GetWalletTransactionsTransactionStatus
        ] = None,
        type_: Optional[models.Type] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DtoListWalletTransactionsResponse:
        r"""Get wallet transactions

        Use when showing transaction history for a wallet (e.g. credit/debit log or audit). Returns a paginated list; supports limit, offset, and filters.

        :param id_path_parameter: Wallet ID
        :param created_by:
        :param credits_available_gt:
        :param end_time:
        :param expand:
        :param expiry_date_after:
        :param expiry_date_before:
        :param id_query_parameter:
        :param limit:
        :param offset:
        :param order:
        :param priority:
        :param reference_id:
        :param reference_type:
        :param start_time:
        :param status:
        :param transaction_reason:
        :param transaction_status:
        :param type:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetWalletTransactionsRequest(
            id_path_parameter=id_path_parameter,
            created_by=created_by,
            credits_available_gt=credits_available_gt,
            end_time=end_time,
            expand=expand,
            expiry_date_after=expiry_date_after,
            expiry_date_before=expiry_date_before,
            id_query_parameter=id_query_parameter,
            limit=limit,
            offset=offset,
            order=order,
            priority=priority,
            reference_id=reference_id,
            reference_type=reference_type,
            start_time=start_time,
            status=status,
            transaction_reason=transaction_reason,
            transaction_status=transaction_status,
            type=type_,
        )

        req = self._build_request(
            method="GET",
            path="/wallets/{id}/transactions",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getWalletTransactions",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.DtoListWalletTransactionsResponse, http_res
            )
        if utils.match_response(http_res, ["400", "404"], "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise models.errors.FlexpriceDefaultError(
            "Unexpected response received", http_res
        )

    async def get_wallet_transactions_async(
        self,
        *,
        id_path_parameter: str,
        created_by: Optional[str] = None,
        credits_available_gt: Optional[float] = None,
        end_time: Optional[str] = None,
        expand: Optional[str] = None,
        expiry_date_after: Optional[str] = None,
        expiry_date_before: Optional[str] = None,
        id_query_parameter: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        order: Optional[models.GetWalletTransactionsOrder] = None,
        priority: Optional[int] = None,
        reference_id: Optional[str] = None,
        reference_type: Optional[str] = None,
        start_time: Optional[str] = None,
        status: Optional[models.GetWalletTransactionsStatus] = None,
        transaction_reason: Optional[
            models.GetWalletTransactionsTransactionReason
        ] = None,
        transaction_status: Optional[
            models.GetWalletTransactionsTransactionStatus
        ] = None,
        type_: Optional[models.Type] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DtoListWalletTransactionsResponse:
        r"""Get wallet transactions

        Use when showing transaction history for a wallet (e.g. credit/debit log or audit). Returns a paginated list; supports limit, offset, and filters.

        :param id_path_parameter: Wallet ID
        :param created_by:
        :param credits_available_gt:
        :param end_time:
        :param expand:
        :param expiry_date_after:
        :param expiry_date_before:
        :param id_query_parameter:
        :param limit:
        :param offset:
        :param order:
        :param priority:
        :param reference_id:
        :param reference_type:
        :param start_time:
        :param status:
        :param transaction_reason:
        :param transaction_status:
        :param type:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetWalletTransactionsRequest(
            id_path_parameter=id_path_parameter,
            created_by=created_by,
            credits_available_gt=credits_available_gt,
            end_time=end_time,
            expand=expand,
            expiry_date_after=expiry_date_after,
            expiry_date_before=expiry_date_before,
            id_query_parameter=id_query_parameter,
            limit=limit,
            offset=offset,
            order=order,
            priority=priority,
            reference_id=reference_id,
            reference_type=reference_type,
            start_time=start_time,
            status=status,
            transaction_reason=transaction_reason,
            transaction_status=transaction_status,
            type=type_,
        )

        req = self._build_request_async(
            method="GET",
            path="/wallets/{id}/transactions",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getWalletTransactions",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.DtoListWalletTransactionsResponse, http_res
            )
        if utils.match_response(http_res, ["400", "404"], "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                models.errors.ErrorsErrorResponseData, http_res
            )
            raise models.errors.ErrorsErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.errors.FlexpriceDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise models.errors.FlexpriceDefaultError(
            "Unexpected response received", http_res
        )
